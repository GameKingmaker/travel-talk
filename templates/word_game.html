{% extends "base.html" %}
{% block content %}

<style>
  .wg-wrap{
    max-width:1080px;
    margin:0 auto;
    padding:22px 18px 56px;
  }

  .wg-head{
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:16px;
    margin-bottom:14px;
  }
  .wg-title{
    font-size:34px;
    font-weight:900;
    letter-spacing:-0.5px;
    margin:0;
  }
  .wg-sub{
    margin:6px 0 0;
    color:#6b7280;
    font-size:14px;
    line-height:1.45;
  }

  .wg-actions{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    height:40px;
    padding:0 14px;
    border-radius:12px;
    border:1px solid rgba(15,23,42,0.10);
    background:#fff;
    text-decoration:none;
    color:#0f172a;
    font-weight:800;
    cursor:pointer;
  }
  .btn.primary{
    background:#2563eb;
    color:#fff;
    border-color:rgba(37,99,235,0.22);
  }
  .btn.ghost{
    background:#f8fafc;
  }

  .wg-panel{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin:14px 0 12px;
  }
  .wg-chip{
    display:flex;
    align-items:center;
    gap:8px;
    padding:10px 12px;
    border-radius:14px;
    background:#fff;
    border:1px solid rgba(15,23,42,0.10);
  }
  .wg-chip b{ font-weight:900; }
  .wg-chip .muted{ color:#64748b; font-size:12px; }

  .wg-box{
    background:#fff;
    border:1px solid rgba(15,23,42,0.10);
    border-radius:18px;
    box-shadow:0 10px 30px rgba(2,8,23,0.06);
    overflow:hidden;
  }

  .wg-arena{
    position:relative;
    height:420px;
    background: linear-gradient(180deg, #f8fbff, #f1f5ff);
    border-bottom:1px solid rgba(15,23,42,0.08);
  }

  .wg-line{
    position:absolute;
    top:0;
    right:0;
    width:10px;
    height:100%;
    background: rgba(239,68,68,0.20);
    border-left:2px solid rgba(239,68,68,0.55);
  }
  .wg-line::after{
    content:"GAME OVER LINE";
    position:absolute;
    top:10px;
    right:12px;
    font-size:11px;
    font-weight:900;
    color:rgba(239,68,68,0.75);
    letter-spacing:0.5px;
  }

  .wg-word{
    position:absolute;
    left:0;
    top:0;
    padding:10px 12px;
    border-radius:14px;
    background:#ffffffcc;
    border:1px solid rgba(37,99,235,0.18);
    box-shadow:0 10px 18px rgba(37,99,235,0.08);
    backdrop-filter: blur(6px);
    user-select:none;
    min-width:120px;
  }
  .wg-word .jp{
    font-size:12px;
    color:#64748b;
    font-weight:700;
    margin-bottom:2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .wg-word .pron{
    font-size:18px;
    font-weight:900;
    color:#0f172a;
    white-space:nowrap;
  }
  .wg-word.hit{
    transform: scale(0.98);
    opacity:0.5;
  }

  .wg-bottom{
    display:flex;
    gap:10px;
    align-items:center;
    padding:12px;
    background:#fff;
  }

  .wg-input{
    flex:1;
    height:44px;
    border-radius:14px;
    border:1px solid rgba(15,23,42,0.12);
    padding:0 14px;
    font-size:15px;
    outline:none;
  }
  .wg-input:focus{
    border-color: rgba(37,99,235,0.40);
    box-shadow: 0 0 0 4px rgba(37,99,235,0.12);
  }

  .wg-hint{
    padding:10px 12px 14px;
    color:#64748b;
    font-size:12px;
    line-height:1.5;
  }

  /* ✅ 오버레이는 화면 중앙 고정 + 바깥 스크롤 허용 */
.wg-overlay{
  position:fixed;          /* 기존 absolute면 fixed로 */
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;            /* 가장자리 여백 */
  background: rgba(2,6,23,0.35);
  backdrop-filter: blur(6px);
  z-index:9999;

  overflow:auto;           /* ✅ 오버레이 자체 스크롤 가능 */
}

/* ✅ 모달: 최대 높이 제한 + 내부 스크롤(드래그) */
.wg-modal{
  width:min(900px, 96vw);
  max-height: min(78vh, 720px);
  background:#fff;
  border-radius:18px;
  border:1px solid rgba(15,23,42,0.10);
  box-shadow:0 20px 60px rgba(2,8,23,0.22);

  display:flex;            /* ✅ 내부를 header/body/footer로 나누기 */
  flex-direction:column;
  overflow:hidden;         /* footer 고정 위해 hidden */
}

/* 모달 상단(제목/설명) 영역 */
.wg-modal-head{
  padding:16px 16px 10px;
  border-bottom:1px solid rgba(15,23,42,0.06);
}
.wg-modal h3{ margin:0; font-size:20px; font-weight:900; letter-spacing:-0.3px; }
.wg-modal p{ margin:8px 0 0; color:#6b7280; font-size:13px; line-height:1.5; }

/* ✅ 모달 본문: 여기만 스크롤(드래그) */
.wg-modal-body{
  padding:12px 16px 14px;
  overflow:auto;           /* ✅ 드래그/휠 스크롤 */
  -webkit-overflow-scrolling: touch;
}

/* ✅ 모드 선택 줄: 항상 보이게 */
.wg-row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:12px;
}

/* ✅ 카테고리: 그리드 유지 + 높이 자동 */
#wgCats{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap:8px;
  margin-top:12px;
  align-items:stretch;
}

/* ✅ 모달 하단 버튼: 항상 아래 고정 */
.wg-modal-foot{
  padding:12px 16px;
  border-top:1px solid rgba(15,23,42,0.06);
  background:#fff;
  display:flex;
  justify-content:flex-end;
  gap:10px;
}

/* ✅ 작은 화면 대응 */
@media (max-width: 560px){
  #wgCats{ grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
  .wg-overlay{ padding:12px; }
}

</style>

<div class="wg-wrap">
  <div class="wg-head">
    <div>
      <h1 class="wg-title">단어 게임</h1>
      <p class="wg-sub">
        화면에 나타나는 <b>발음</b>을 보고, 아래 입력칸에 <b>한국어 뜻</b>을 입력하세요.<br>
        단어가 오른쪽 <b>빨간 선</b>을 넘으면 게임오버!
      </p>
    </div>

    <div class="wg-actions">
      <a class="btn ghost" href="{{ url_for('quiz') }}">← 게임 선택</a>
      <a class="btn" href="{{ url_for('word_game_ranking_page') }}">랭킹 보기</a>
      <button class="btn" id="wgResetBtn" type="button">재시작</button>
      <button class="btn primary" id="wgStartBtn" type="button">단어 선택</button>
    </div>
  </div>

  <div class="wg-panel">
    <div class="wg-chip"><b>점수</b> <span id="wgScore">0</span></div>
    <div class="wg-chip"><b>남은 풀</b> <span id="wgPool">-</span></div>
  </div>

  <div class="wg-box">
  <div class="wg-arena" id="wgArena">
    <div class="wg-line" id="wgLine"></div>

    <div class="wg-overlay" id="wgOverlay">
      <div class="wg-modal">

        <!-- ✅ 상단(고정) -->
        <div class="wg-modal-head">
          <h3>단어 게임 설정</h3>
          <p>카테고리를 선택하면 그 범위에서 단어가 나와요. (미선택 시 전체)</p>
        </div>

        <!-- ✅ 본문(스크롤/드래그 되는 영역) -->
        <div class="wg-modal-body">
          <div class="wg-row" style="margin-top:10px;">
            <label class="wg-select">
              <input type="radio" name="wgMode" value="practice" checked>
              <b>연습 모드</b>
              <span style="color:#64748b;font-size:12px;">(카테고리 선택 가능 / 풀 끝나면 클리어)</span>
            </label>

            <label class="wg-select">
              <input type="radio" name="wgMode" value="rank">
              <b>랭킹 모드</b>
              <span style="color:#64748b;font-size:12px;">(전체 단어 / 점수 저장 / 무한)</span>
            </label>
          </div>

          <div id="wgCats"></div>
        </div>

        <!-- ✅ 하단(고정) -->
        <div class="wg-modal-foot">
          <button class="btn" id="wgOverlayClose" type="button">닫기</button>
          <button class="btn primary" id="wgOverlayStart" type="button">게임 시작</button>
        </div>

      </div>
    </div>
  </div>
</div>


    <div class="wg-bottom">
      <input class="wg-input" id="wgInput" type="text" placeholder="여기에 한국어 뜻을 입력하고 Enter!" autocomplete="off" />
      <button class="btn" id="wgSubmit" type="button">Enter</button>
    </div>

    <div class="wg-hint">
      팁) 정답 비교는 <b>앞뒤 공백 제거</b> 후 정확히 일치하는지로 판단해요. (예: “화장실”)<br>
      필요하면 뜻 데이터를 더 자연스럽게(동의어 처리) 확장해줄 수도 있어요.
    </div>
  </div>
</div>

<script>
(() => {
  const arena = document.getElementById("wgArena");
  const lineEl = document.getElementById("wgLine");
  const overlay = document.getElementById("wgOverlay");
  const catsWrap = document.getElementById("wgCats");

  const startBtn = document.getElementById("wgStartBtn");
  const resetBtn = document.getElementById("wgResetBtn");
  const overlayStart = document.getElementById("wgOverlayStart");
  const overlayClose = document.getElementById("wgOverlayClose");

  const input = document.getElementById("wgInput");
  const submitBtn = document.getElementById("wgSubmit");

  const scoreEl = document.getElementById("wgScore");
  const poolEl = document.getElementById("wgPool");

  const toast = (msg) => {
    if (typeof window.showToast === "function") window.showToast(msg);
    else alert(msg);
  };

  let allCats = [];       // {key,title,count}
  let currentCats = [];   // 마지막으로 적용된 카테고리(재시작에 사용)
  let pool = [];          // {cat_key,cat_title,jp,pron,ko}
  let active = [];        // {el,x,y,speed,word}
  let rafId = null;
  let running = false;

  let score = 0;
  let cleared = 0;

  // ✅ 고정 속도/고정 스폰
  const FIXED_SPEED = 15;     // px/sec (원하면 28~40 사이로 조절)
  const FIXED_SPAWN = 1200;   // ms (원하면 900~1500 사이로 조절)

  let spawnEvery = FIXED_SPAWN;
  let spawnTimer = null;

  let scoreSaved = false;

  function norm(s){ return String(s || "").trim(); }

  function normAnswer(s){
    let t = norm(s);
    t = t.replace(/\([^)]*\)/g, "");
    t = t.replace(/[,\s]/g, "");
    t = t.replace(/원/g, "");
    if (t === "만") return "10000";
    if (t === "만원") return "10000";

    let m = t.match(/^(\d+)만$/);
    if (m){
      const n = parseInt(m[1], 10);
      if (!Number.isNaN(n)) return String(n * 10000);
    }

    m = t.match(/^(\d+)만원$/);
    if (m){
      const n = parseInt(m[1], 10);
      if (!Number.isNaN(n)) return String(n * 10000);
    }

    return t;
  }

  function splitAnswers(s){
    let t = String(s || "");
    t = t.replace(/\([^)]*\)/g, "");
    t = t.replace(/또는|or/gi, "/");
    t = t.replace(/[·,|]/g, "/");
    return t.split("/").map(x => normAnswer(x)).filter(Boolean);
  }

  function isCorrectAnswer(userInput, answerRaw){
    const u = normAnswer(userInput);
    if (!u) return false;
    const candidates = splitAnswers(answerRaw);
    if (!candidates.length) return false;
    return candidates.includes(u);
  }

  function getMode(){
    const r = overlay.querySelector('input[name="wgMode"]:checked');
    return r ? r.value : "practice";
  }

  function toggleCatsUI(){
    const mode = getMode();
    catsWrap.style.display = (mode === "rank") ? "none" : "grid";
  }

  async function loadPool(selectedCats){
    const qs = new URLSearchParams();
    qs.set("n", "99999");
    if (selectedCats && selectedCats.length){
      qs.set("cats", selectedCats.join(","));
    }

    const res = await fetch("/api/game_words?" + qs.toString());
    const data = await res.json();
    if (!data || !data.ok) throw new Error("pool load failed");

    pool = Array.isArray(data.items) ? data.items : [];
    poolEl.textContent = String(pool.length);

    if (!allCats.length){
      const map = new Map();
      for (const it of pool){
        const k = it.cat_key;
        if (!map.has(k)) map.set(k, {key:k, title: it.cat_title || k, count:0});
        map.get(k).count += 1;
      }
      allCats = Array.from(map.values()).sort((a,b) => a.title.localeCompare(b.title, "ko"));
      renderCats(allCats);
    }
  }

  function renderCats(cats){
    catsWrap.innerHTML = "";
    for (const c of cats){
      const label = document.createElement("label");
      label.className = "wg-select";
      label.innerHTML =
        `<input type="checkbox" value="${c.key}">
         <b>${c.title}</b>
         <span style="color:#64748b;font-size:12px;">(${c.count})</span>`;
      catsWrap.appendChild(label);
    }
  }

  function getSelectedCats(){
    const checks = catsWrap.querySelectorAll("input[type=checkbox]:checked");
    return Array.from(checks).map(x => x.value);
  }

  function clearArenaWords(){
    for (const a of active){
      if (a.el && a.el.parentNode) a.el.parentNode.removeChild(a.el);
    }
    active = [];
  }

  function setHUD(){
    scoreEl.textContent = String(score);
    poolEl.textContent = String(pool.length);
  }

  async function submitRankScoreIfNeeded(){
    if (getMode() !== "rank") return;
    try{
      const res = await fetch("/api/word_game/submit_score", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({score})
      });
      if (res.status === 401) return toast("랭킹 저장은 로그인 후 가능합니다.");
      const data = await res.json();
      if (data && data.ok){
        if (data.updated) toast(`신기록! ${data.best}점`);
        else toast(`기록: ${data.best}점 (최고기록 유지)`);
      }
    }catch(e){}
  }

  async function stopGameCommon(){
    running = false;
    if (spawnTimer) clearInterval(spawnTimer);
    spawnTimer = null;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    input.blur();
    overlay.style.display = "flex";
  }

  async function gameOver(reason){
    if (scoreSaved) return;
    scoreSaved = true;
    await stopGameCommon();
    await submitRankScoreIfNeeded();
    toast(reason || `게임오버! 점수: ${score}점`);
  }

  async function gameClear(){
    await stopGameCommon();
    toast(`클리어! 점수: ${score}점 (총 ${cleared}개 정답)`);
  }

  function spawnWord(){
    if (!running) return;

    if (!pool.length){
      if (getMode() === "rank"){
        loadPool([]).catch(()=>{});
      }
      return;
    }

    const it = pool.pop();
    poolEl.textContent = String(pool.length);

    const el = document.createElement("div");
    el.className = "wg-word";
    el.innerHTML = `
      <div class="jp">${it.jp}</div>
      <div class="pron">${it.pron}</div>
    `;
    arena.appendChild(el);

    const arenaRect = arena.getBoundingClientRect();
    const maxY = Math.max(20, arenaRect.height - 80);
    const y = 18 + Math.random() * (maxY - 18);
    const x = - (120 + Math.random() * 100);

    active.push({
      el,
      x,
      y,
      speed: FIXED_SPEED + Math.random() * 2, // ✅ 거의 고정(약간의 자연스러움만)
      word: it
    });

    el.style.transform = `translate(${x}px, ${y}px)`;
  }

  function tick(){
    if (!running) return;

    const lineRect = lineEl.getBoundingClientRect();
    const lineLeft = lineRect.left;

    for (const a of active){
      a.x += (a.speed / 60);
      a.el.style.transform = `translate(${a.x}px, ${a.y}px)`;

      const r = a.el.getBoundingClientRect();
      if (r.right >= lineLeft){
        gameOver(`게임오버! 점수: ${score}점`);
        return;
      }
    }

    if (getMode() === "practice" && pool.length === 0 && active.length === 0){
      gameClear();
      return;
    }

    rafId = requestAnimationFrame(tick);
  }

  function tryHit(){
    if (!running) return;

    const v = norm(input.value);

    if (!v){
      input.value = "";
      input.focus();
      input.classList.add("shake");
      setTimeout(()=>input.classList.remove("shake"), 220);
      return;
    }

    const idx = active.findIndex(a => isCorrectAnswer(v, a.word.ko));
    if (idx === -1){
      input.value = "";
      input.focus();

      input.classList.add("shake");
      setTimeout(()=>input.classList.remove("shake"), 240);

      input.disabled = true;
      setTimeout(()=>{ input.disabled = false; input.focus(); }, 180);
      return;
    }

    const a = active[idx];
    a.el.classList.add("hit");

    score += 1;
    cleared += 1;
    setHUD();

    setTimeout(() => {
      if (a.el && a.el.parentNode) a.el.parentNode.removeChild(a.el);
    }, 90);

    active.splice(idx, 1);

    input.value = "";
    input.focus();

    spawnWord();
  }

  function startGame(){
    scoreSaved = false;

    clearArenaWords();
    score = 0;
    cleared = 0;

    spawnEvery = FIXED_SPAWN;

    setHUD();

    running = true;
    overlay.style.display = "none";
    input.focus();

    spawnWord();
    if (pool.length) spawnWord();

    if (spawnTimer) clearInterval(spawnTimer);
    spawnTimer = setInterval(spawnWord, spawnEvery);

    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  async function openOverlay(){
    overlay.style.display = "flex";
    if (!allCats.length){
      await loadPool([]);
    }
    toggleCatsUI();
  }

  async function applyCatsAndStart(){
    const mode = getMode();

    if (mode === "rank") {
      currentCats = [];
      await loadPool([]);
    } else {
      const selected = getSelectedCats();
      currentCats = selected.length ? selected : [];
      await loadPool(currentCats);
      if (!pool.length){
        toast("선택한 카테고리에 단어가 없어요.");
        return;
      }
    }

    startGame();
  }

  startBtn.addEventListener("click", () => openOverlay().catch(()=>toast("불러오기 실패")));

  resetBtn.addEventListener("click", async () => {
    try{
      const mode = getMode();
      if (mode === "rank") await loadPool([]);
      else await loadPool(currentCats);
      startGame();
    }catch(e){
      toast("재시작 실패(데이터 불러오기 실패)");
    }
  });

  overlayStart.addEventListener("click", () => {
    applyCatsAndStart().catch(()=>toast("게임 데이터를 불러오지 못했어요."));
  });

  overlayClose.addEventListener("click", () => {
    overlay.style.display = "none";
  });

  overlay.addEventListener("change", (e) => {
    if (e.target && e.target.name === "wgMode") toggleCatsUI();
  });

  submitBtn.addEventListener("click", tryHit);
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") tryHit();
  });

  openOverlay().catch(()=>{});
})();
</script>

{% endblock %}
